---
title: Chapter 3 – Geocentric Models
author: "Danton Noriega-Goodwin"
date: 2024-02-02
---

```{julia}
#| code-fold: true

# set-up
using Plots
using Colors
using Random
using StatsBase
using StatsPlots
using DataFrames
using NamedArrays
using Distributions
using SpecialFunctions

default(
  labels=false, fontfamily="sans-serif", titlefontsize=8, labelfontsize=6,
  legendfontsize=4)
```


### Code 3.1

```{julia}
pos = [ sum(rand(Uniform(-1,1), 16)) for _ in 1:1000 ];
```

### Fig 3.2
```{julia}
# NOT IN BOOK
## ATTEMPT TO REPLICATE FIG 3.2
function random_walk(n_steps=4, N=1000)
  [ rand(Uniform(-1,1), n_steps) for _ in 1:N ]
end

# final position after N steps
pos_steps_4  = [ sum(_) for _ in random_walk( 4) ];
pos_steps_8  = [ sum(_) for _ in random_walk( 8) ];
pos_steps_16 = [ sum(_) for _ in random_walk(16) ];

# position after each step (path)
path_steps_16 = map( x -> cumsum(vcat(0,x)), random_walk(16,200) );

l = @layout [ grid(1,1) ; grid(1,3) ]
plots = Plots.Plot[ plot() for i in 1:4 ]
plots[1] = plot(0:16, hcat(path_steps_16...), linealpha = 0.2, 
  ylabel="position", xlabel="step number", color=:steelblue2)
plot!( plots[1], 0:16, path_steps_16[42], 
      xticks=0:4:16, linecolor=:black, linewidth=1.5)
vline!( plots[1], [4,8,16], linecolor=:black, 
      linewidth=1.5, linestyle=:dash)

plots[2:4] .= 
  density( pos_steps_4 , linewidth=2, bandwidth=0.05, ylabel="density",
          xtickfontsize=6, titlefontsize=8, title="4 steps"),
  density( pos_steps_8 , linewidth=2, bandwidth=0.05, 
          xtickfontsize=6, titlefontsize=8, title="8 steps"),
  density( pos_steps_16, linewidth=2, bandwidth=0.05, 
          xtickfontsize=6, titlefontsize=8, title="16 steps")

# add normal curve
x_values = -6:0.1:6
μ = mean(pos_steps_16)
σ = std(pos_steps_16)
y_values = pdf(Normal(μ, σ), x_values)
plot!(plots[4], x_values, y_values, linecolor=:black, linewidth=2)
plot( plots..., layout=l )
```

### Code 3.2

```{julia}
function sim_weight( H , b , sd )
  U = rand(Normal(0, sd), length(H))
  W = b * H + U
  W
end
```

### Code 3.3

```{julia}
H = rand(Uniform(130, 170), 200);
W = sim_weight(H, 0.5, 5);
plot(H, W, seriestype=:scatter, markerstrokecolor=:red, markeralpha=.8,
     markercolor=:white, markersize=4, markerstrokewidth=3,
     ylabel="W", xlabel="H")
```

### Code 3.4
```{julia}
beta_seq = collect(0:.1:1)
```

### Code 3.5

```{julia}
Random.seed!(93);
H = rand(Uniform(130, 170), 1);
W = sim_weight(H, 0.5, 10);
```

### Code 3.6

Need to define `compute_post` ([Code 3.12](#code-3.12))

```{julia}
# reproduce `log_sum_exp`
function log_sum_exp(x)
  xmax = maximum(x)
  xsum = sum( exp.( x .- xmax ) )
  xmax + log(xsum)
end

function compute_logPrW(W, H, a, b, sigma, prior=1)
  mu = a .+ b .* H
  sum(logpdf.(Normal.(mu, sigma), W)) + log(prior)
end

function compute_post(W, H, a, b, sigma, prior=1)
  G = [[a, b[j], sigma] for j in 1:length(b)]
  # Compute probability of each
  post = [compute_logPrW(W, H, G[i][1], G[i][2], G[i][3], 1) 
          for i in 1:length(G)]
  post = exp.(post .- log_sum_exp(post))
  # SOURCE
  # https://discourse.julialang.org/t/how-to-convert-vector-of-vectors-to-matrix/72609/27
  hcat(stack(G, dims=1), post)
end
```

```{julia}
# code 3.6
beta_seq = collect(0:.1:1)
post = compute_post(W,H,0,beta_seq,10)
NamedArray(round.(post', digits=3), (["a", "b", "sigma", "post"], 1:length(beta_seq)), ("vars","elem"))
```

### Code 3.7

```{julia}
bar(beta_seq, post[:,4], xlabel="beta", ylabel="posterior probability")
```

